using System;
using System.Drawing;

namespace figura_4
{
    /// <summary>
    /// Clase que maneja la geometría y el dibujo de la figura hexagonal
    /// </summary>
    public class FiguraGeometrica
    {
        #region Propiedades
        
        public float Radio { get; set; }
        public float AnguloRotacion { get; set; }
        public float Escala { get; set; }
        public int NivelDibujo { get; set; }
        public float DesplazamientoX { get; set; }
        public float DesplazamientoY { get; set; }
        
        #endregion

        #region Constantes
        
        private const int NUMERO_HEXAGONOS = 6;
        private const int NUMERO_VERTICES = 6;
        private const int NUMERO_ANILLOS = 5;
        private const float PASO_MOVIMIENTO = 5f;
        
        #endregion

        #region Constructor
        
        public FiguraGeometrica()
        {
            Radio = 100f;
            AnguloRotacion = 0f;
            Escala = 1.0f;
            NivelDibujo = 0;
            DesplazamientoX = 0f;
            DesplazamientoY = 0f;
        }
        
        #endregion

        #region Métodos de Cálculo Geométrico
        
        /// <summary>
        /// Calcula los centros de los hexágonos externos
        /// </summary>
        private PointF[] CalcularCentrosHexagonos(PointF centro)
        {
            PointF[] centros = new PointF[NUMERO_HEXAGONOS];
            float radioMitad = ObtenerRadioEscalado() / 2;
            float angulo = (float)Math.PI + AnguloRotacion;
            float incrementoAngulo = (float)Math.PI * 2 / NUMERO_HEXAGONOS;

            for (int i = 0; i < NUMERO_HEXAGONOS; i++)
            {
                float x = centro.X + (float)(radioMitad * Math.Sin(angulo));
                float y = centro.Y + (float)(radioMitad * Math.Cos(angulo));
                centros[i] = new PointF(x, y);
                angulo += incrementoAngulo;
            }

            return centros;
        }

        /// <summary>
        /// Calcula los vértices de todos los hexágonos concéntricos
        /// </summary>
        private PointF[,,] CalcularVerticesHexagonos(PointF[] centros)
        {
            PointF[,,] vertices = new PointF[NUMERO_HEXAGONOS, NUMERO_VERTICES, NUMERO_ANILLOS];
            float radioMitad = ObtenerRadioEscalado() / 2;
            float parteMitad = radioMitad / NUMERO_ANILLOS;

            for (int i = 0; i < NUMERO_HEXAGONOS; i++)
            {
                for (int anillo = 0; anillo < NUMERO_ANILLOS; anillo++)
                {
                    float radioActual = parteMitad * (anillo + 1);
                    float angulo = (float)Math.PI + AnguloRotacion;
                    float incrementoAngulo = (float)Math.PI * 2 / NUMERO_VERTICES;

                    for (int vertice = 0; vertice < NUMERO_VERTICES; vertice++)
                    {
                        float x = centros[i].X + (float)(radioActual * Math.Sin(angulo));
                        float y = centros[i].Y + (float)(radioActual * Math.Cos(angulo));
                        vertices[i, vertice, anillo] = new PointF(x, y);
                        angulo += incrementoAngulo;
                    }
                }
            }

            return vertices;
        }

        /// <summary>
        /// Obtiene el radio escalado
        /// </summary>
        private float ObtenerRadioEscalado()
        {
            return Radio * Escala;
        }

        /// <summary>
        /// Obtiene el centro de la figura con el desplazamiento aplicado
        /// </summary>
        private PointF ObtenerCentroConDesplazamiento(Size tamanoCanvas)
        {
            return new PointF(
                (tamanoCanvas.Width / 2f) + DesplazamientoX,
                (tamanoCanvas.Height / 2f) + DesplazamientoY
            );
        }
        
        #endregion

        #region Métodos de Dibujo
        
        /// <summary>
        /// Dibuja la figura completa en el gráfico especificado
        /// </summary>
        public void Dibujar(Graphics g, Size tamanoCanvas)
        {
            if (g == null) return;

            g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;
            g.Clear(Color.White);

            PointF centro = ObtenerCentroConDesplazamiento(tamanoCanvas);
            PointF[] centros = CalcularCentrosHexagonos(centro);
            PointF[,,] vertices = CalcularVerticesHexagonos(centros);

            using (Pen lapiz = new Pen(Color.Black, 1))
            {
                // Nivel 1: Dibujar líneas desde el centro
                if (NivelDibujo >= 1)
                {
                    DibujarLineasCentrales(g, lapiz, centro, centros);
                }

                // Nivel 2+: Dibujar anillos concéntricos
                if (NivelDibujo >= 2)
                {
                    DibujarAnillosConcéntricos(g, lapiz, vertices);
                }
            }
        }

        /// <summary>
        /// Dibuja las líneas desde el centro hacia los centros de los hexágonos
        /// </summary>
        private void DibujarLineasCentrales(Graphics g, Pen lapiz, PointF centro, PointF[] centros)
        {
            for (int i = 0; i < NUMERO_HEXAGONOS; i++)
            {
                g.DrawLine(lapiz, centro, centros[i]);
            }
        }

        /// <summary>
        /// Dibuja los anillos concéntricos de los hexágonos
        /// </summary>
        private void DibujarAnillosConcéntricos(Graphics g, Pen lapiz, PointF[,,] vertices)
        {
            int maxAnillos = ObtenerNumeroAnillosPorNivel();

            for (int hexagono = 0; hexagono < NUMERO_HEXAGONOS; hexagono++)
            {
                for (int anillo = 0; anillo < maxAnillos; anillo++)
                {
                    DibujarLadosHexagono(g, lapiz, vertices, hexagono, anillo);
                }
            }
        }

        /// <summary>
        /// Dibuja los lados específicos de un hexágono según su posición
        /// </summary>
        private void DibujarLadosHexagono(Graphics g, Pen lapiz, PointF[,,] vertices, int hexagono, int anillo)
        {
            for (int lado = 0; lado < NUMERO_VERTICES; lado++)
            {
                if (DebesDibujarLado(hexagono, lado))
                {
                    int ladoSiguiente = (lado + 1) % NUMERO_VERTICES;
                    g.DrawLine(lapiz,
                        vertices[hexagono, lado, anillo],
                        vertices[hexagono, ladoSiguiente, anillo]);
                }
            }
        }

        /// <summary>
        /// Determina si un lado específico debe dibujarse según el hexágono
        /// </summary>
        private bool DebesDibujarLado(int hexagono, int lado)
        {
            switch (hexagono)
            {
                case 0: return lado == 3 || lado == 4 || lado == 5 || lado == 0;
                case 1: return lado == 4 || lado == 5 || lado == 0 || lado == 1;
                case 2: return lado == 5 || lado == 0 || lado == 1 || lado == 2;
                case 3: return lado == 0 || lado == 1 || lado == 2 || lado == 3;
                case 4: return lado == 1 || lado == 2 || lado == 3 || lado == 4;
                case 5: return lado == 2 || lado == 3 || lado == 4 || lado == 5;
                default: return false;
            }
        }

        /// <summary>
        /// Obtiene el número de anillos a dibujar según el nivel actual
        /// </summary>
        private int ObtenerNumeroAnillosPorNivel()
        {
            if (NivelDibujo >= 5)
                return NUMERO_ANILLOS;
            
            return Math.Max(0, NivelDibujo - 1);
        }
        
        #endregion

        #region Métodos de Transformación
        
        /// <summary>
        /// Rota la figura en grados
        /// </summary>
        public void Rotar(float grados)
        {
            AnguloRotacion += grados * (float)Math.PI / 180f;
        }

        /// <summary>
        /// Mueve la figura hacia arriba
        /// </summary>
        public void MoverArriba()
        {
            DesplazamientoY -= PASO_MOVIMIENTO;
        }

        /// <summary>
        /// Mueve la figura hacia abajo
        /// </summary>
        public void MoverAbajo()
        {
            DesplazamientoY += PASO_MOVIMIENTO;
        }

        /// <summary>
        /// Mueve la figura hacia la izquierda
        /// </summary>
        public void MoverIzquierda()
        {
            DesplazamientoX -= PASO_MOVIMIENTO;
        }

        /// <summary>
        /// Mueve la figura hacia la derecha
        /// </summary>
        public void MoverDerecha()
        {
            DesplazamientoX += PASO_MOVIMIENTO;
        }

        /// <summary>
        /// Reinicia todos los parámetros a sus valores por defecto
        /// </summary>
        public void Reiniciar()
        {
            Radio = 100f;
            AnguloRotacion = 0f;
            Escala = 1.0f;
            NivelDibujo = 0;
            DesplazamientoX = 0f;
            DesplazamientoY = 0f;
        }
        
        #endregion
    }
}
