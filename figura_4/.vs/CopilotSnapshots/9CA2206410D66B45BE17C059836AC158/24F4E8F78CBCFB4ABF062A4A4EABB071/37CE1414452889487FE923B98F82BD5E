using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace figura_4
{
    #region Clase FiguraGeometrica
    
    /// <summary>
    /// Clase que maneja la geometría y el dibujo de la figura hexagonal
    /// </summary>
    public class FiguraGeometrica
    {
        #region Propiedades
        
        public float Radio { get; set; }
        public float AnguloRotacion { get; set; }
        public float Escala { get; set; }
        public int NivelDibujo { get; set; }
        
        #endregion

        #region Constantes
        
        private const int NUMERO_HEXAGONOS = 6;
        private const int NUMERO_VERTICES = 6;
        private const int NUMERO_ANILLOS = 5;
        
        #endregion

        #region Constructor
        
        public FiguraGeometrica()
        {
            Radio = 100f;
            AnguloRotacion = 0f;
            Escala = 1.0f;
            NivelDibujo = 0;
        }
        
        #endregion

        #region Métodos de Cálculo Geométrico
        
        /// <summary>
        /// Calcula los centros de los hexágonos externos
        /// </summary>
        private PointF[] CalcularCentrosHexagonos(PointF centro)
        {
            PointF[] centros = new PointF[NUMERO_HEXAGONOS];
            float radioMitad = ObtenerRadioEscalado() / 2;
            float angulo = (float)Math.PI + AnguloRotacion;
            float incrementoAngulo = (float)Math.PI * 2 / NUMERO_HEXAGONOS;

            for (int i = 0; i < NUMERO_HEXAGONOS; i++)
            {
                float x = centro.X + (float)(radioMitad * Math.Sin(angulo));
                float y = centro.Y + (float)(radioMitad * Math.Cos(angulo));
                centros[i] = new PointF(x, y);
                angulo += incrementoAngulo;
            }

            return centros;
        }

        /// <summary>
        /// Calcula los vértices de todos los hexágonos concéntricos
        /// </summary>
        private PointF[,,] CalcularVerticesHexagonos(PointF[] centros)
        {
            PointF[,,] vertices = new PointF[NUMERO_HEXAGONOS, NUMERO_VERTICES, NUMERO_ANILLOS];
            float radioMitad = ObtenerRadioEscalado() / 2;
            float parteMitad = radioMitad / NUMERO_ANILLOS;

            for (int i = 0; i < NUMERO_HEXAGONOS; i++)
            {
                for (int anillo = 0; anillo < NUMERO_ANILLOS; anillo++)
                {
                    float radioActual = parteMitad * (anillo + 1);
                    float angulo = (float)Math.PI + AnguloRotacion;
                    float incrementoAngulo = (float)Math.PI * 2 / NUMERO_VERTICES;

                    for (int vertice = 0; vertice < NUMERO_VERTICES; vertice++)
                    {
                        float x = centros[i].X + (float)(radioActual * Math.Sin(angulo));
                        float y = centros[i].Y + (float)(radioActual * Math.Cos(angulo));
                        vertices[i, vertice, anillo] = new PointF(x, y);
                        angulo += incrementoAngulo;
                    }
                }
            }

            return vertices;
        }

        /// <summary>
        /// Obtiene el radio escalado
        /// </summary>
        private float ObtenerRadioEscalado()
        {
            return Radio * Escala;
        }
        
        #endregion

        #region Métodos de Dibujo
        
        /// <summary>
        /// Dibuja la figura completa en el gráfico especificado
        /// </summary>
        public void Dibujar(Graphics g, Size tamanoCanvas)
        {
            if (g == null) return;

            g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;
            g.Clear(Color.White);

            PointF centro = new PointF(tamanoCanvas.Width / 2f, tamanoCanvas.Height / 2f);
            PointF[] centros = CalcularCentrosHexagonos(centro);
            PointF[,,] vertices = CalcularVerticesHexagonos(centros);

            using (Pen lapiz = new Pen(Color.Black, 1))
            {
                // Nivel 1: Dibujar líneas desde el centro
                if (NivelDibujo >= 1)
                {
                    DibujarLineasCentrales(g, lapiz, centro, centros);
                }

                // Nivel 2+: Dibujar anillos concéntricos
                if (NivelDibujo >= 2)
                {
                    DibujarAnillosConcéntricos(g, lapiz, vertices);
                }
            }
        }

        /// <summary>
        /// Dibuja las líneas desde el centro hacia los centros de los hexágonos
        /// </summary>
        private void DibujarLineasCentrales(Graphics g, Pen lapiz, PointF centro, PointF[] centros)
        {
            for (int i = 0; i < NUMERO_HEXAGONOS; i++)
            {
                g.DrawLine(lapiz, centro, centros[i]);
            }
        }

        /// <summary>
        /// Dibuja los anillos concéntricos de los hexágonos
        /// </summary>
        private void DibujarAnillosConcéntricos(Graphics g, Pen lapiz, PointF[,,] vertices)
        {
            int maxAnillos = ObtenerNumeroAnillosPorNivel();

            for (int hexagono = 0; hexagono < NUMERO_HEXAGONOS; hexagono++)
            {
                for (int anillo = 0; anillo < maxAnillos; anillo++)
                {
                    DibujarLadosHexagono(g, lapiz, vertices, hexagono, anillo);
                }
            }
        }

        /// <summary>
        /// Dibuja los lados específicos de un hexágono según su posición
        /// </summary>
        private void DibujarLadosHexagono(Graphics g, Pen lapiz, PointF[,,] vertices, int hexagono, int anillo)
        {
            for (int lado = 0; lado < NUMERO_VERTICES; lado++)
            {
                if (DebesDibujarLado(hexagono, lado))
                {
                    int ladoSiguiente = (lado + 1) % NUMERO_VERTICES;
                    g.DrawLine(lapiz,
                        vertices[hexagono, lado, anillo],
                        vertices[hexagono, ladoSiguiente, anillo]);
                }
            }
        }

        /// <summary>
        /// Determina si un lado específico debe dibujarse según el hexágono
        /// </summary>
        private bool DebesDibujarLado(int hexagono, int lado)
        {
            switch (hexagono)
            {
                case 0: return lado == 3 || lado == 4 || lado == 5 || lado == 0;
                case 1: return lado == 4 || lado == 5 || lado == 0 || lado == 1;
                case 2: return lado == 5 || lado == 0 || lado == 1 || lado == 2;
                case 3: return lado == 0 || lado == 1 || lado == 2 || lado == 3;
                case 4: return lado == 1 || lado == 2 || lado == 3 || lado == 4;
                case 5: return lado == 2 || lado == 3 || lado == 4 || lado == 5;
                default: return false;
            }
        }

        /// <summary>
        /// Obtiene el número de anillos a dibujar según el nivel actual
        /// </summary>
        private int ObtenerNumeroAnillosPorNivel()
        {
            if (NivelDibujo >= 5)
                return NUMERO_ANILLOS;
            
            return Math.Max(0, NivelDibujo - 1);
        }
        
        #endregion

        #region Métodos de Transformación
        
        /// <summary>
        /// Rota la figura en grados
        /// </summary>
        public void Rotar(float grados)
        {
            AnguloRotacion += grados * (float)Math.PI / 180f;
        }

        /// <summary>
        /// Reinicia todos los parámetros a sus valores por defecto
        /// </summary>
        public void Reiniciar()
        {
            Radio = 100f;
            AnguloRotacion = 0f;
            Escala = 1.0f;
            NivelDibujo = 0;
        }
        
        #endregion
    }
    
    #endregion

    #region Formulario Principal
    
    /// <summary>
    /// Formulario principal para dibujar pentágonos y polígonos estrellados
    /// </summary>
    public partial class Form1 : Form
    {
        #region Campos Privados
        
        private Bitmap canvas;
        private FiguraGeometrica figura;
        
        #endregion

        #region Constructor
        
        public Form1()
        {
            InitializeComponent();
            InicializarComponentes();
        }
        
        #endregion

        #region Inicialización
        
        /// <summary>
        /// Inicializa los componentes y configuraciones del formulario
        /// </summary>
        private void InicializarComponentes()
        {
            canvas = new Bitmap(picCanvas.Width, picCanvas.Height);
            figura = new FiguraGeometrica();
            picCanvas.Image = canvas;
        }
        
        #endregion

        #region Eventos de Botones - Entradas
        
        /// <summary>
        /// Maneja el evento click del botón Graficar
        /// </summary>
        private void btnCalcular_Click(object sender, EventArgs e)
        {
            if (ValidarEntradaRadio(out float radioInput))
            {
                ConfigurarParametrosFigura(radioInput);
                ActualizarDibujo();
            }
            else
            {
                MostrarMensajeError("Por favor ingresa un valor numérico válido.");
            }
        }

        /// <summary>
        /// Maneja el evento click del botón Resetear
        /// </summary>
        private void btnResetear_Click(object sender, EventArgs e)
        {
            ReiniciarFigura();
            LimpiarCanvas();
        }
        
        #endregion

        #region Eventos de Botones - Rotación
        
        /// <summary>
        /// Maneja el evento click del botón rotar antihorario (-5°)
        /// </summary>
        private void btnRotarAntihorario_Click(object sender, EventArgs e)
        {
            figura.Rotar(-5f);
            ActualizarDibujo();
        }

        /// <summary>
        /// Maneja el evento click del botón rotar horario (+5°)
        /// </summary>
        private void btnRotarHorario_Click(object sender, EventArgs e)
        {
            figura.Rotar(5f);
            ActualizarDibujo();
        }
        
        #endregion

        #region Eventos de Control - TrackBar
        
        /// <summary>
        /// Maneja el evento scroll del TrackBar de tamaño
        /// </summary>
        private void trackBarTamano_Scroll(object sender, EventArgs e)
        {
            figura.Escala = trackBarTamano.Value / 100f;
            ActualizarDibujo();
        }
        
        #endregion

        #region Eventos de Botones - Paso a Paso
        
        /// <summary>
        /// Maneja el evento click del botón Anterior
        /// </summary>
        private void btnAnterior_Click(object sender, EventArgs e)
        {
            if (figura.NivelDibujo > 0)
            {
                figura.NivelDibujo--;
                ActualizarDibujo();
            }
        }

        /// <summary>
        /// Maneja el evento click del botón Siguiente
        /// </summary>
        private void btnSiguiente_Click(object sender, EventArgs e)
        {
            if (figura.NivelDibujo < 5)
            {
                figura.NivelDibujo++;
                ActualizarDibujo();
            }
        }
        
        #endregion

        #region Métodos de Dibujo
        
        /// <summary>
        /// Actualiza el dibujo de la figura en el canvas
        /// </summary>
        private void ActualizarDibujo()
        {
            canvas = new Bitmap(picCanvas.Width, picCanvas.Height);
            
            using (Graphics g = Graphics.FromImage(canvas))
            {
                figura.Dibujar(g, picCanvas.Size);
            }
            
            picCanvas.Image = canvas;
            picCanvas.Refresh();
        }

        /// <summary>
        /// Limpia el canvas y lo actualiza
        /// </summary>
        private void LimpiarCanvas()
        {
            canvas = new Bitmap(picCanvas.Width, picCanvas.Height);
            picCanvas.Image = canvas;
            picCanvas.Refresh();
        }
        
        #endregion

        #region Métodos de Configuración
        
        /// <summary>
        /// Configura los parámetros de la figura para dibujar
        /// </summary>
        private void ConfigurarParametrosFigura(float radio)
        {
            figura.Radio = radio;
            figura.Escala = trackBarTamano.Value / 100f;
            figura.NivelDibujo = 5; // Mostrar todo
        }

        /// <summary>
        /// Reinicia la figura y los controles a sus valores por defecto
        /// </summary>
        private void ReiniciarFigura()
        {
            figura.Reiniciar();
            trackBarTamano.Value = 100;
            txtTamano.Text = "100";
        }
        
        #endregion

        #region Métodos de Validación
        
        /// <summary>
        /// Valida la entrada del radio desde el TextBox
        /// </summary>
        private bool ValidarEntradaRadio(out float radio)
        {
            return float.TryParse(txtTamano.Text, out radio) && radio > 0;
        }
        
        #endregion

        #region Métodos de UI
        
        /// <summary>
        /// Muestra un mensaje de error al usuario
        /// </summary>
        private void MostrarMensajeError(string mensaje)
        {
            MessageBox.Show(mensaje, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
        }
        
        #endregion

        #region Eventos de Formulario (Generados por Designer)
        
        private void grpBox_Enter(object sender, EventArgs e)
        {
            // Evento generado por el diseñador
        }

        private void label1_Click(object sender, EventArgs e)
        {
            // Evento generado por el diseñador
        }

        private void txtTamano_TextChanged(object sender, EventArgs e)
        {
            // Evento generado por el diseñador
        }
        
        #endregion
    }
    
    #endregion
}
