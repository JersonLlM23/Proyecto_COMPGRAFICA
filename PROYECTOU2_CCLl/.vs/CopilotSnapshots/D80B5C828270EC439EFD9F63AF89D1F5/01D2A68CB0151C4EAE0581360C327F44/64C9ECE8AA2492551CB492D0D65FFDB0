using System;
using System.Drawing;

namespace PROYECTO_U2_CCLl
{
    /// <summary>
    /// Representa un cono 3D con propiedades de transformación
    /// </summary>
    public class Cone3D
    {
  public string Name { get; set; }
     public Vector3D Position { get; set; }
        public Vector3D Rotation { get; set; }
        public Vector3D Translation { get; set; }
   public Color Color { get; set; }
        public float Height { get; set; }
   public float Radius { get; set; }
     public int Segments { get; set; }

        public Cone3D(string name)
        {
            Name = name;
        Position = new Vector3D(0, 0, 0);
   Rotation = new Vector3D(0, 0, 0);
         Translation = new Vector3D(0, 0, 0);
            Color = Color.Blue;
   Height = 2.0f;
      Radius = 1.0f;
            Segments = 20;
        }

        /// <summary>
        /// Genera los vértices del cono en 3D
        /// </summary>
        public Vector3D[] GenerateVertices()
   {
            Vector3D[] vertices = new Vector3D[Segments + 2];
            
     // Vértice superior (ápice del cono)
            vertices[0] = new Vector3D(0, Height, 0);
            
   // Vértices de la base circular
            for (int i = 0; i <= Segments; i++)
    {
     float angle = (float)(2 * Math.PI * i / Segments);
 float x = Radius * (float)Math.Cos(angle);
      float z = Radius * (float)Math.Sin(angle);
             vertices[i + 1] = new Vector3D(x, 0, z);
       }
            
            return vertices;
        }

        /// <summary>
        /// Aplica todas las transformaciones a un vértice
        /// </summary>
        public Vector3D TransformVertex(Vector3D vertex)
        {
   // Aplicar rotación
       Vector3D rotated = RotateVertex(vertex, Rotation);
        
   // Aplicar translación
          rotated.X += Translation.X;
            rotated.Y += Translation.Y;
    rotated.Z += Translation.Z;
   
            // Aplicar posición
            rotated.X += Position.X;
        rotated.Y += Position.Y;
   rotated.Z += Position.Z;
            
    return rotated;
    }

        private Vector3D RotateVertex(Vector3D vertex, Vector3D rotation)
        {
       // Convertir grados a radianes
            float angleX = rotation.X * (float)Math.PI / 180.0f;
    float angleY = rotation.Y * (float)Math.PI / 180.0f;
            float angleZ = rotation.Z * (float)Math.PI / 180.0f;

          // Rotación alrededor del eje X
     float y1 = vertex.Y * (float)Math.Cos(angleX) - vertex.Z * (float)Math.Sin(angleX);
       float z1 = vertex.Y * (float)Math.Sin(angleX) + vertex.Z * (float)Math.Cos(angleX);
      
            // Rotación alrededor del eje Y
            float x2 = vertex.X * (float)Math.Cos(angleY) + z1 * (float)Math.Sin(angleY);
  float z2 = -vertex.X * (float)Math.Sin(angleY) + z1 * (float)Math.Cos(angleY);
  
   // Rotación alrededor del eje Z
        float x3 = x2 * (float)Math.Cos(angleZ) - y1 * (float)Math.Sin(angleZ);
            float y3 = x2 * (float)Math.Sin(angleZ) + y1 * (float)Math.Cos(angleZ);
     
            return new Vector3D(x3, y3, z2);
        }

  /// <summary>
        /// Proyecta un punto 3D a coordenadas 2D de pantalla usando proyección perspectiva
    /// </summary>
        public PointF ProjectTo2D(Vector3D point, float cameraDistance, Size canvasSize)
    {
            float perspective = cameraDistance / (cameraDistance + point.Z);
   float x2d = point.X * perspective * 100 + canvasSize.Width / 2;
    float y2d = -point.Y * perspective * 100 + canvasSize.Height / 2;
            return new PointF(x2d, y2d);
        }

        /// <summary>
      /// Dibuja el cono en el Graphics especificado
    /// </summary>
        public void Draw(Graphics g, Size canvasSize, float cameraDistance)
     {
    Vector3D[] vertices = GenerateVertices();
            PointF[] projectedPoints = new PointF[vertices.Length];
          
            // Transformar y proyectar todos los vértices
  for (int i = 0; i < vertices.Length; i++)
 {
   Vector3D transformed = TransformVertex(vertices[i]);
    projectedPoints[i] = ProjectTo2D(transformed, cameraDistance, canvasSize);
            }
            
       using (Pen pen = new Pen(Color, 2))
            {
         // Dibujar líneas desde el ápice hasta cada vértice de la base
         for (int i = 1; i <= Segments; i++)
 {
           g.DrawLine(pen, projectedPoints[0], projectedPoints[i]);
                }
      
          // Dibujar el círculo de la base
              for (int i = 1; i < Segments; i++)
       {
                  g.DrawLine(pen, projectedPoints[i], projectedPoints[i + 1]);
}
        // Cerrar el círculo
    g.DrawLine(pen, projectedPoints[Segments], projectedPoints[1]);
            }
  }
    }

    /// <summary>
    /// Representa un vector en 3D
    /// </summary>
    public class Vector3D
    {
     public float X { get; set; }
     public float Y { get; set; }
   public float Z { get; set; }

  public Vector3D(float x, float y, float z)
      {
      X = x;
         Y = y;
   Z = z;
 }

        public override string ToString()
        {
    return $"({X:F2}, {Y:F2}, {Z:F2})";
        }
    }
}
