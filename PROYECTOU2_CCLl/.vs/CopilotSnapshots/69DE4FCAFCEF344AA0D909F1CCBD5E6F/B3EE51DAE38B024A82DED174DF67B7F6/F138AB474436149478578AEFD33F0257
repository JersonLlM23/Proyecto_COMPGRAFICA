using System;
using System.Drawing;

namespace PROYECTO_U2_CCLl
{
    /// <summary>
    /// Representa un cilindro 3D con transformaciones y renderizado
    /// </summary>
    public class Cylinder3D : Shape3D
    {
        public float Radius { get; set; }
  public float Height { get; set; }
        public int Segments { get; set; }

     public Cylinder3D(string name) : base(name)
        {
            Color = Color.Green;
    Radius = 0.5f;
            Height = 1.0f;
    Segments = 20;
        }

     /// <summary>
      /// Genera los vértices del cilindro
        /// </summary>
        public override Vector3D[] GenerateVertices()
     {
            // Top circle + Bottom circle + centers
Vector3D[] vertices = new Vector3D[Segments * 2 + 2];
   
       // Vértices del círculo superior
     for (int i = 0; i < Segments; i++)
            {
       float angle = (float)(2 * Math.PI * i / Segments);
     float x = Radius * (float)Math.Cos(angle);
  float z = Radius * (float)Math.Sin(angle);
         vertices[i] = new Vector3D(x, Height / 2, z);
  }
   
        // Vértices del círculo inferior
for (int i = 0; i < Segments; i++)
  {
float angle = (float)(2 * Math.PI * i / Segments);
    float x = Radius * (float)Math.Cos(angle);
  float z = Radius * (float)Math.Sin(angle);
   vertices[Segments + i] = new Vector3D(x, -Height / 2, z);
      }
       
    // Centro del círculo superior
  vertices[Segments * 2] = new Vector3D(0, Height / 2, 0);
        
         // Centro del círculo inferior
       vertices[Segments * 2 + 1] = new Vector3D(0, -Height / 2, 0);
    
            return vertices;
      }

   /// <summary>
        /// Dibuja el cilindro en el Graphics especificado
      /// </summary>
        public override void Draw(Graphics g, Size screenSize, float cameraDistance)
        {
       Vector3D[] vertices = GenerateVertices();
 PointF[] projectedPoints = new PointF[vertices.Length];
        
      // Transformar y proyectar todos los vértices
   for (int i = 0; i < vertices.Length; i++)
            {
      Vector3D transformed = TransformVertex(vertices[i]);
       projectedPoints[i] = ProjectTo2D(transformed, cameraDistance, screenSize);
  }
   
     using (Pen pen = new Pen(Color, 1))
    using (SolidBrush brush = new SolidBrush(Color.FromArgb(100, Color)))
    {
     // Dibujar líneas verticales conectando los círculos
     for (int i = 0; i < Segments; i++)
          {
    g.DrawLine(pen, projectedPoints[i], projectedPoints[Segments + i]);
 }

       // Dibujar el círculo superior
    for (int i = 0; i < Segments; i++)
     {
         int next = (i + 1) % Segments;
        g.DrawLine(pen, projectedPoints[i], projectedPoints[next]);
    }
     
   // Dibujar el círculo inferior
   for (int i = 0; i < Segments; i++)
   {
      int next = (i + 1) % Segments;
        g.DrawLine(pen, projectedPoints[Segments + i], projectedPoints[Segments + next]);
     }
     
    // Rellenar la superficie lateral con triángulos (semi-transparente)
 for (int i = 0; i < Segments; i++)
   {
     int next = (i + 1) % Segments;
   
       // Primer triángulo del cuadrilátero
    PointF[] triangle1 = new PointF[] 
  { 
         projectedPoints[i], 
       projectedPoints[next],
    projectedPoints[Segments + i]
      };
    g.FillPolygon(brush, triangle1);
         
   // Segundo triángulo del cuadrilátero
    PointF[] triangle2 = new PointF[] 
          { 
        projectedPoints[next],
  projectedPoints[Segments + next],
    projectedPoints[Segments + i]
       };
    g.FillPolygon(brush, triangle2);
    }
   
     // Rellenar el círculo superior
  PointF[] topCircle = new PointF[Segments];
   for (int i = 0; i < Segments; i++)
          {
     topCircle[i] = projectedPoints[i];
 }
        g.FillPolygon(brush, topCircle);
       
  // Rellenar el círculo inferior
     PointF[] bottomCircle = new PointF[Segments];
       for (int i = 0; i < Segments; i++)
        {
bottomCircle[i] = projectedPoints[Segments + i];
  }
       g.FillPolygon(brush, bottomCircle);
        }
        }
    }
}
