using System;
using System.Drawing;

namespace PROYECTO_U2_CCLl
{
    /// <summary>
    /// Representa un cono 3D con transformaciones y renderizado
    /// </summary>
    public class Cone3D
    {
      public string Name { get; set; }
    public Color Color { get; set; }
        public Vector3D Position { get; set; }
   public Vector3D Rotation { get; set; }
    public Vector3D Translation { get; set; }
   public float Radius { get; set; }
        public float Height { get; set; }
     public int Segments { get; set; }

   public Cone3D(string name)
      {
     Name = name;
            Color = Color.Blue;
       Position = new Vector3D(0, 0, 0);
            Rotation = new Vector3D(0, 0, 0);
         Translation = new Vector3D(0, 0, 0);
       Radius = 0.5f;
            Height = 1.0f;
         Segments = 20;
        }

        /// <summary>
        /// Genera los vértices del cono
        /// </summary>
        public Vector3D[] GenerateVertices()
        {
   Vector3D[] vertices = new Vector3D[Segments + 2];
            
       // Vértice superior (punta del cono)
     vertices[0] = new Vector3D(0, Height / 2, 0);
   
   // Vértices de la base circular
            for (int i = 0; i < Segments; i++)
            {
      float angle = (float)(2 * Math.PI * i / Segments);
    float x = Radius * (float)Math.Cos(angle);
        float z = Radius * (float)Math.Sin(angle);
  vertices[i + 1] = new Vector3D(x, -Height / 2, z);
      }
    
            // Centro de la base
          vertices[Segments + 1] = new Vector3D(0, -Height / 2, 0);
   
            return vertices;
        }

        /// <summary>
        /// Aplica las transformaciones (rotación, translación, posición) a un vértice
        /// </summary>
        public Vector3D TransformVertex(Vector3D vertex)
        {
            Vector3D transformed = new Vector3D(vertex.X, vertex.Y, vertex.Z);
            
   // Aplicar rotación
    transformed = RotateX(transformed, Rotation.X);
   transformed = RotateY(transformed, Rotation.Y);
      transformed = RotateZ(transformed, Rotation.Z);

       // Aplicar translación
            transformed.X += Translation.X;
          transformed.Y += Translation.Y;
       transformed.Z += Translation.Z;
  
            // Aplicar posición
   transformed.X += Position.X / 10.0f;
transformed.Y += Position.Y / 10.0f;
  transformed.Z += Position.Z / 10.0f;
         
       return transformed;
        }

        /// <summary>
 /// Rotación alrededor del eje X
        /// </summary>
        private Vector3D RotateX(Vector3D v, float angle)
    {
       float rad = angle * (float)Math.PI / 180.0f;
            float cos = (float)Math.Cos(rad);
       float sin = (float)Math.Sin(rad);

    return new Vector3D(
             v.X,
           v.Y * cos - v.Z * sin,
     v.Y * sin + v.Z * cos
            );
        }

        /// <summary>
   /// Rotación alrededor del eje Y
      /// </summary>
        private Vector3D RotateY(Vector3D v, float angle)
        {
          float rad = angle * (float)Math.PI / 180.0f;
       float cos = (float)Math.Cos(rad);
      float sin = (float)Math.Sin(rad);
            
            return new Vector3D(
     v.X * cos + v.Z * sin,
       v.Y,
            -v.X * sin + v.Z * cos
            );
        }

        /// <summary>
        /// Rotación alrededor del eje Z
    /// </summary>
        private Vector3D RotateZ(Vector3D v, float angle)
        {
  float rad = angle * (float)Math.PI / 180.0f;
 float cos = (float)Math.Cos(rad);
      float sin = (float)Math.Sin(rad);
            
       return new Vector3D(
       v.X * cos - v.Y * sin,
                v.X * sin + v.Y * cos,
                v.Z
 );
        }

        /// <summary>
        /// Proyecta un punto 3D a coordenadas 2D de pantalla usando proyección en perspectiva
      /// </summary>
        public PointF ProjectTo2D(Vector3D point, float cameraDistance, Size screenSize)
   {
   float perspective = cameraDistance / (cameraDistance + point.Z);
            
    float x = point.X * 100 * perspective + screenSize.Width / 2;
       float y = -point.Y * 100 * perspective + screenSize.Height / 2;
 
            return new PointF(x, y);
     }

        /// <summary>
    /// Dibuja el cono en el Graphics especificado
        /// </summary>
  public void Draw(Graphics g, Size screenSize, float cameraDistance)
        {
  Vector3D[] vertices = GenerateVertices();
   PointF[] projectedPoints = new PointF[vertices.Length];
      
            // Transformar y proyectar todos los vértices
         for (int i = 0; i < vertices.Length; i++)
  {
     Vector3D transformed = TransformVertex(vertices[i]);
          projectedPoints[i] = ProjectTo2D(transformed, cameraDistance, screenSize);
    }
          
    using (Pen pen = new Pen(Color, 1))
  using (SolidBrush brush = new SolidBrush(Color.FromArgb(100, Color)))
   {
            // Dibujar las líneas laterales del cono (de la punta a la base)
 for (int i = 1; i <= Segments; i++)
          {
            g.DrawLine(pen, projectedPoints[0], projectedPoints[i]);
     }
                
       // Dibujar la base circular
            for (int i = 1; i <= Segments; i++)
              {
         int next = (i == Segments) ? 1 : i + 1;
       g.DrawLine(pen, projectedPoints[i], projectedPoints[next]);
       }
       
         // Rellenar triángulos de la superficie lateral (semi-transparente)
          for (int i = 1; i <= Segments; i++)
      {
              int next = (i == Segments) ? 1 : i + 1;
         PointF[] triangle = new PointF[] 
                 { 
    projectedPoints[0], 
       projectedPoints[i], 
  projectedPoints[next] 
              };
     g.FillPolygon(brush, triangle);
       }
  
           // Rellenar la base
        PointF[] basePoints = new PointF[Segments];
    for (int i = 0; i < Segments; i++)
                {
        basePoints[i] = projectedPoints[i + 1];
  }
           g.FillPolygon(brush, basePoints);
            }
        }
    }
}
